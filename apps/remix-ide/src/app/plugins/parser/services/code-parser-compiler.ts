'use strict'
import { CompilerAbstract } from '@remix-project/remix-solidity'
import { Compiler } from '@remix-project/remix-solidity'

import { AstNode, CompilationError, CompilationResult, CompilationSource } from '@remix-project/remix-solidity'
import { helper } from '@remix-project/remix-solidity'
import { CodeParser } from "../code-parser";
import { fileDecoration, fileDecorationType } from '@remix-ui/file-decorators'

export default class CodeParserCompiler {
    plugin: CodeParser
    compiler: any // used to compile the current file seperately from the main compiler
    onAstFinished: (success: any, data: CompilationResult, source: CompilationSource, input: any, version: any) => Promise<void>;
    errorState: boolean;
    gastEstimateTimeOut: any
    constructor(
        plugin: CodeParser
    ) {
        this.plugin = plugin
    }

    init() {

        this.onAstFinished = async (success, data: CompilationResult, source: CompilationSource, input: any, version) => {
            console.log('compile success', success, data, this)
            this.plugin.call('editor', 'clearAnnotations')
            this.errorState = true
            const checkIfFatalError = (error: CompilationError) => {
                // Ignore warnings and the 'Deferred import' error as those are generated by us as a workaround
                const isValidError = (error.message && error.message.includes('Deferred import')) ? false : error.severity !== 'warning'
                if (isValidError) {
                    console.log(error)
                }
            }
            const result = new CompilerAbstract('soljson', data, source, input)

            if (data.error) checkIfFatalError(data.error)
            if (data.errors) data.errors.forEach((err) => checkIfFatalError(err))
            const allErrors: any = []
            if (data.errors) {
                const sources = result.getSourceCode().sources
                for (const error of data.errors) {
                    const pos = helper.getPositionDetails(error.formattedMessage)
                    const filePosition = Object.keys(sources).findIndex((fileName) => fileName === error.sourceLocation.file)
                    const lineColumn = await this.plugin.call('offsetToLineColumnConverter', 'offsetToLineColumn',
                        {
                            start: error.sourceLocation.start,
                            length: error.sourceLocation.end - error.sourceLocation.start
                        },
                        filePosition,
                        result.getSourceCode().sources,
                        null)
                    allErrors.push({ error, lineColumn })
                }
                console.log('allErrors', allErrors)
                await this.plugin.call('editor', 'addErrorMarker', allErrors)

                const errorsPerFiles = {}
                for (const error of allErrors) {
                    if (!errorsPerFiles[error.error.sourceLocation.file]) {
                        errorsPerFiles[error.error.sourceLocation.file] = []
                    }
                    errorsPerFiles[error.error.sourceLocation.file].push(error.error)
                }

                const errorPriority = {
                    'error': 0,
                    'warning': 1,
                }

                // sort errorPerFiles by error priority
                const sortedErrorsPerFiles = {}
                for (const fileName in errorsPerFiles) {
                    const errors = errorsPerFiles[fileName]
                    errors.sort((a, b) => {
                        return errorPriority[a.severity] - errorPriority[b.severity]
                    }
                    )
                    sortedErrorsPerFiles[fileName] = errors
                }
                console.log('sortedErrorsPerFiles', sortedErrorsPerFiles)

                const filesWithOutErrors = Object.keys(sources).filter((fileName) => !sortedErrorsPerFiles[fileName])

                console.log('filesWithOutErrors', filesWithOutErrors)
                // add decorators
                const decorators: fileDecoration[] = []
                for (const fileName in sortedErrorsPerFiles) {
                    const errors = sortedErrorsPerFiles[fileName]
                    const decorator: fileDecoration = {
                        path: fileName,
                        isDirectory: false,
                        fileStateType: errors[0].severity === 'error' ? fileDecorationType.Error : fileDecorationType.Warning,
                        fileStateLabelClass: errors[0].severity === 'error' ? 'text-danger' : 'text-warning',
                        fileStateIconClass: '',
                        fileStateIcon: '',
                        text: errors.length,
                        owner: 'code-parser',
                        bubble: true,
                        commment: errors.map((error) => error.message),
                    }
                    decorators.push(decorator)
                }
                for (const fileName of filesWithOutErrors) {
                    const decorator: fileDecoration = {
                        path: fileName,
                        isDirectory: false,
                        fileStateType: fileDecorationType.None,
                        fileStateLabelClass: '',
                        fileStateIconClass: '',
                        fileStateIcon: '',
                        text: '',
                        owner: 'code-parser',
                        bubble: false
                    }
                    decorators.push(decorator)
                }
                console.log(decorators)
                await this.plugin.call('fileDecorator', 'setFileDecorators', decorators)
                await this.plugin.call('editor', 'clearErrorMarkers', filesWithOutErrors)
            } else {
                await this.plugin.call('editor', 'clearErrorMarkers', result.getSourceCode().sources)
                const decorators: fileDecoration[] = []
                for (const fileName of Object.keys(result.getSourceCode().sources)) {
                    const decorator: fileDecoration = {
                        path: fileName,
                        isDirectory: false,
                        fileStateType: fileDecorationType.None,
                        fileStateLabelClass: '',
                        fileStateIconClass: '',
                        fileStateIcon: '',
                        text: '',
                        owner: 'code-parser',
                        bubble: false
                    }
                    decorators.push(decorator)
                }
                console.log(decorators)

                await this.plugin.call('fileDecorator', 'setFileDecorators', decorators)

            }


            if (!data.sources) return
            if (data.sources && Object.keys(data.sources).length === 0) return
            this.plugin.lastCompilationResult = new CompilerAbstract('soljson', data, source, input)

            this.errorState = false
            this.plugin._index = {
                Declarations: {},
                FlatReferences: {},
                NodesPerFile: {},
            }
            this.plugin._buildIndex(data, source)

            if (this.gastEstimateTimeOut) {
                window.clearTimeout(this.gastEstimateTimeOut)
            }

            this.gastEstimateTimeOut = window.setTimeout(async () => {
                await this.plugin.gasService.showGasEstimates()
            }, 1000)

            console.log("INDEX", this.plugin._index)
            this.plugin.emit('astFinished')
        }

        this.compiler = new Compiler((url, cb) => this.plugin.call('contentImport', 'resolveAndSave', url, undefined, true).then((result) => cb(null, result)).catch((error) => cb(error.message)))
        this.compiler.event.register('compilationFinished', this.onAstFinished)
    }

        // COMPILER

    /**
     * 
     * @returns 
     */
     async compile() {
        try {
            const state = await this.plugin.call('solidity', 'getCompilerState')
            this.compiler.set('optimize', state.optimize)
            this.compiler.set('evmVersion', state.evmVersion)
            this.compiler.set('language', state.language)
            this.compiler.set('runs', state.runs)
            this.compiler.set('useFileConfiguration', state.useFileConfiguration)
            this.plugin.currentFile = await this.plugin.call('fileManager', 'file')
            console.log(this.plugin.currentFile)
            if (!this.plugin.currentFile) return
            const content = await this.plugin.call('fileManager', 'readFile', this.plugin.currentFile)
            const sources = { [this.plugin.currentFile]: { content } }
            this.compiler.compile(sources, this.plugin.currentFile)
        } catch (e) {
            console.log(e)
        }
    }

}